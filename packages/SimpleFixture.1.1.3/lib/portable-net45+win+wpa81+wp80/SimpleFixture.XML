<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleFixture</name>
    </assembly>
    <members>
        <member name="T:SimpleFixture.BehaviorCollection">
            <summary>
            A collection of behavior functions to be applied to objects
            </summary>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add(System.Func{SimpleFixture.DataRequest,System.Object,System.Object})">
            <summary>
            Add behavior that will be run against every object returned by the fixture.
            </summary>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add``1(System.Func{SimpleFixture.DataRequest,``0,``0})">
            <summary>
            Add Behavior to be run on specified type
            </summary>
            <typeparam name="T">type of object to apply the behavior to</typeparam>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add``1(System.Action{``0})">
            <summary>
            Add behavior for specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Apply(SimpleFixture.DataRequest,System.Object)">
            <summary>
            Apply all the behaviors in the collection to an instance
            </summary>
            <param name="request">data request</param>
            <param name="instance">instance</param>
            <returns>instance</returns>
        </member>
        <member name="T:SimpleFixture.WhenFilter`1">
            <summary>
            Filter for behavior
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.When(System.Func{SimpleFixture.DataRequest,`0,System.Boolean})">
            <summary>
            Execute behavior when func returns true
            </summary>
            <param name="filter">when filter</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.WhenRequestName(System.Func{System.String,System.Boolean})">
            <summary>
            Execute behavior when request name matches
            </summary>
            <param name="filter">filter by request name</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.WhenRequestedFor``1">
            <summary>
            Execute behavior when requested for a particular parent type
            </summary>
            <typeparam name="TRequest"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.IConvention">
            <summary>
            Convention for satisifying a data request
            </summary>
        </member>
        <member name="M:SimpleFixture.IConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="P:SimpleFixture.IConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.IConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.SimpleTypeConvention`1">
            <summary>
            Abstract simple type convention
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:SimpleFixture.ITypedConvention">
            <summary>
            Conventions implementing this interface support a specific set of types
            </summary>
        </member>
        <member name="P:SimpleFixture.ITypedConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.SimpleTypeConvention`1.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate date for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="M:SimpleFixture.Conventions.SimpleTypeConvention`1.RaisePriorityChanged(SimpleFixture.ConventionPriority)">
            <summary>
            Raise priority changed event
            </summary>
            <param name="priority"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.SimpleTypeConvention`1.Priority">
            <summary>
            Priority for the convention, last by default
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.SimpleTypeConvention`1.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.SimpleTypeConvention`1.SupportedTypes">
            <summary>
            Supported types
            </summary>
        </member>
        <member name="T:SimpleFixture.DataRequest">
            <summary>
            Object representing a data request
            </summary>
        </member>
        <member name="M:SimpleFixture.DataRequest.#ctor(SimpleFixture.DataRequest,System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="parentRequest">parent request</param>
            <param name="requestedType">new type to create</param>
        </member>
        <member name="M:SimpleFixture.DataRequest.#ctor(SimpleFixture.DataRequest,SimpleFixture.Fixture,System.Type,System.String,System.Boolean,System.Object,System.Object)">
            <summary>
            Date request constructor
            </summary>
            <param name="parentRequest">parent request</param>
            <param name="fixture">fixture this request is associated with</param>
            <param name="requestedType">type being requested</param>
            <param name="requestName">request name for this request</param>
            <param name="populate">populate properties</param>
            <param name="constraints">constraints object</param>
            <param name="extraInfo">extra info (PropertyInfo or ParameterInfo)</param>
        </member>
        <member name="P:SimpleFixture.DataRequest.ParentRequest">
            <summary>
            Parent request
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Fixture">
            <summary>
            Fixture this request is associated with
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestName">
            <summary>
            Request name
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestedType">
            <summary>
            Type being requested
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Populate">
            <summary>
            Populate public properties
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Constraints">
            <summary>
            Constraints object for request
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.ExtraInfo">
            <summary>
            Extra Info for request (PropertyInfo or ParameterInfo)
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestDepth">
            <summary>
            Request Depth
            </summary>
        </member>
        <member name="T:SimpleFixture.DefaultFixtureConfiguration">
            <summary>
            Default configuration for Fixture
            </summary>
        </member>
        <member name="T:SimpleFixture.DI.GContainer">
            <summary>
            Simple dependency injection container
            </summary>
        </member>
        <member name="T:SimpleFixture.DI.IGContainer">
            <summary>
            Simple dependency injection container interface
            </summary>
        </member>
        <member name="M:SimpleFixture.DI.IGContainer.Export``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a particular type
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export function</param>
        </member>
        <member name="M:SimpleFixture.DI.IGContainer.Locate``1">
            <summary>
            Locate instance of T
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>instance of T</returns>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.Export``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a particular type
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export function</param>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.ExportSingleton``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a type as a singleton
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="exportFunc">export func</param>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.Locate``1">
            <summary>
            Locate an instance of T
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>new instance of T</returns>
        </member>
        <member name="T:SimpleFixture.IFixtureConfiguration">
            <summary>
            Configuration interface for SimpleFixture. Only implement this interface if you want to change the internal worksings of SimpleFixture
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.UseDefaultConventions">
            <summary>
            Use default conventions for primitive types as well as string
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.UseNamedConventions">
            <summary>
            Use conventions that try and assign values based on parameter or property names
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.ItemCount">
            <summary>
            If set this will indicate how many items to generate for IEnumerables and other colletions.
            If null then the convention is free to do what it wants
            </summary>
        </member>
        <member name="M:SimpleFixture.DefaultFixtureConfiguration.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.UseDefaultConventions">
            <summary>
            Use default conventions, true by default
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.UseNamedConventions">
            <summary>
            Use named conventions, true by default
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.ItemCount">
            <summary>
            Item count controls the how many instances should be constructed when populating enumerables
            </summary>
        </member>
        <member name="T:SimpleFixture.ExportAs`1">
            <summary>
            Fluent helper class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ExportAs`1.#ctor(SimpleFixture.Fixture,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="fixture"></param>
            <param name="isSingleton"></param>
        </member>
        <member name="M:SimpleFixture.ExportAs`1.As``1">
            <summary>
            As a specific implementation
            </summary>
            <typeparam name="TExport"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Fixture">
            <summary>
            Testing fixture
            </summary>
        </member>
        <member name="M:SimpleFixture.Fixture.#ctor(SimpleFixture.IFixtureConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:SimpleFixture.Fixture.Locate(System.Type,System.String,System.Object)">
            <summary>
            Creates a new instance of the specified type. It does not populate any properties
            </summary>
            <param name="type">type to create</param>
            <param name="requestName"></param>
            <param name="constraints"></param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Locate``1(System.String,System.Object)">
            <summary>
            Creates a new instance of T. It does not populate any properties
            </summary>
            <typeparam name="T">type to create</typeparam>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate(SimpleFixture.DataRequest)">
            <summary>
            Create a new instance of the requested type and populate all public writable properties
            </summary>
            <param name="request">data request</param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate(System.Type,System.String,System.Object)">
            <summary>
            Generate a new instance of the specified type and populate public writable properties
            </summary>
            <param name="type">type to create</param>
            <param name="name">name of the request</param>
            <param name="constraints">constraints to apply to the request</param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate``1(System.String,System.Object)">
            <summary>
            Generate a new instance of T and populate public writable properties
            </summary>
            <typeparam name="T">type to create</typeparam>
            <param name="name">request name</param>
            <param name="constraints">constraint object</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Freeze``1(System.String,System.Object,System.Action{SimpleFixture.ReturnConfiguration{``0}})">
            <summary>
            Generate a new value and add it to the Fixture as a Return
            </summary>
            <typeparam name="T">type to generate</typeparam>
            <param name="requestName">request name</param>
            <param name="constraints">constraints for generate</param>
            <param name="value">action to specify when to use the froozen value (value: i => i.For&lt;T&gt;)</param>
            <returns>new T</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Populate(System.Object,System.Object)">
            <summary>
            Populate writable properties on instance
            </summary>
            <param name="instance">instance to populate</param>
            <param name="constraints">constraint object</param>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(``0[])">
            <summary>
            Return the specified sequence
            </summary>
            <typeparam name="T">Type to return</typeparam>
            <param name="returnValues">return values</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(System.Func{``0})">
            <summary>
            Provide a function that will be invoked when T is need
            </summary>
            <typeparam name="T">type to return</typeparam>
            <param name="returnFunc">return function</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Provide a function that will be invoked when T is need
            </summary>
            <typeparam name="T">type to return</typeparam>
            <param name="returnFunc">return function</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ReturnIEnumerable``1(``0[])">
            <summary>
            Return a set of T as an IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">T Type for IEnumerable</typeparam>
            <param name="set">set of T</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Export``1">
            <summary>
            Export specific implementation as an interface, you must call As after
            </summary>
            <typeparam name="T">Type being exported</typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ExportSingleton``1">
            <summary>
            Export specific implemantion as a singleton interface, you must call As after
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Add(SimpleFixture.IConvention)">
            <summary>
            Add a convention to fixture
            </summary>
            <param name="convention">new convention</param>
        </member>
        <member name="M:SimpleFixture.Fixture.Add(SimpleFixture.IFixtureCustomization)">
            <summary>
            Add customization
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:SimpleFixture.Fixture.Customize``1">
            <summary>
            Customize the creation of a particular type
            </summary>
            <typeparam name="T">type ot customize</typeparam>
            <returns>customize object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:SimpleFixture.Fixture.Configuration">
            <summary>
            Configuration for the fixture
            </summary>
        </member>
        <member name="P:SimpleFixture.Fixture.Behavior">
            <summary>
            Allows you to apply a behavior to every object created by the fixture
            </summary>
        </member>
        <member name="T:SimpleFixture.Convention">
            <summary>
            class with special values
            </summary>
        </member>
        <member name="F:SimpleFixture.Convention.NoValue">
            <summary>
            Value to return instead of null
            </summary>
        </member>
        <member name="T:SimpleFixture.ConventionPriority">
            <summary>
            Convention priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.First">
            <summary>
            First convention to try
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.High">
            <summary>
            High priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Normal">
            <summary>
            Normal priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Low">
            <summary>
            Low priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Last">
            <summary>
            Last convention tried
            </summary>
        </member>
        <member name="T:SimpleFixture.PriorityChangedEventArgs">
            <summary>
            Event args for when priority changes
            </summary>
        </member>
        <member name="F:SimpleFixture.PriorityChangedEventArgs.Priority">
            <summary>
            Priority
            </summary>
        </member>
        <member name="T:SimpleFixture.ICustomizeModel`1">
            <summary>
            Interface for customizing how a Type gets created
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.New(System.Func{`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">function to create new T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.New(System.Func{SimpleFixture.DataRequest,`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">delegate that accepts a data request and returns T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``1(System.Func{``0,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn
            </summary>
            <typeparam name="TIn">type for dependency</typeparam>
            <param name="factory">new factory that takes TIn</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``2(System.Func{``0,``1,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1 and TIn2
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <param name="factory">new factory that takes TIn1 and TIn2</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, and TIn3
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, and TIn3</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``4(System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, TIn3, and TIn4
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <typeparam name="TIn4">fourth dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, TIn3, and TIn4</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="value">value to use when setting property</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Object)">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">property value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Skip``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Skip a particular property from being populated
            </summary>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">property expression</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SkipProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SkipProperties(System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Apply(System.Action{`0})">
            <summary>
            Apply a piece of logic to each instance being created
            </summary>
            <param name="applyAction">apply function</param>
            <returns>customization instanc</returns>
        </member>
        <member name="T:SimpleFixture.IFixtureCustomization">
            <summary>
            This interface allows you to package a set of customization for reuse. 
            </summary>
        </member>
        <member name="M:SimpleFixture.IFixtureCustomization.Customize(SimpleFixture.Fixture)">
            <summary>
            Customize the fixture
            </summary>
            <param name="fixture">fixture to customize</param>
        </member>
        <member name="T:SimpleFixture.Impl.ICircularReferenceHandler">
            <summary>
            interface to handle circular references
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.ICircularReferenceHandler.HandleCircularReference(SimpleFixture.DataRequest)">
            <summary>
            Handle circular reference
            </summary>
            <param name="request">data request that has caused the circular reference</param>
            <returns>data request value</returns>
        </member>
        <member name="T:SimpleFixture.Impl.CircularReferenceHandler">
            <summary>
            Default implementation of ICircularReferenceHandler, throws an exception
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.CircularReferenceHandler.HandleCircularReference(SimpleFixture.DataRequest)">
            <summary>
            Handle circular reference
            </summary>
            <param name="request">data request that has caused the circular reference</param>
            <returns>data request value</returns>
        </member>
        <member name="T:SimpleFixture.Impl.CustomizeModel`1">
            <summary>
            Object used to customize a model
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.#ctor(SimpleFixture.Impl.ComplexModel)">
            <summary>
            Default Constructor
            </summary>
            <param name="complexModel"></param>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.New(System.Func{`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">function to create new T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.New(System.Func{SimpleFixture.DataRequest,`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">delegate that accepts a data request and returns T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``1(System.Func{``0,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn
            </summary>
            <typeparam name="TIn">type for dependency</typeparam>
            <param name="factory">new factory that takes TIn</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``2(System.Func{``0,``1,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1 and TIn2
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <param name="factory">new factory that takes TIn1 and TIn2</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, and TIn3
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, and TIn3</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``4(System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, TIn3, and TIn4
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <typeparam name="TIn4">fourth dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, TIn3, and TIn4</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="value">value to use when setting property</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Object)">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">property value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Skip``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Skip a particular property from being populated
            </summary>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">property expression</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SkipProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SkipProperties(System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Apply(System.Action{`0})">
            <summary>
            Apply a piece of logic to each instance being created
            </summary>
            <param name="applyAction">apply function</param>
            <returns>customization instanc</returns>
        </member>
        <member name="T:SimpleFixture.Impl.TypedConventions">
            <summary>
            Convention that handles ITypeConvention
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.#ctor(SimpleFixture.IFixtureConfiguration,SimpleFixture.ConventionPriority)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
            <param name="priority"></param>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.AddConvention(SimpleFixture.ITypedConvention)">
            <summary>
            Add typed convention
            </summary>
            <param name="typedConvention">convention</param>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request
            </summary>
            <param name="request">data request</param>
            <returns></returns>
        </member>
        <member name="P:SimpleFixture.Impl.TypedConventions.Priority">
            <summary>
            Priority for convention
            </summary>
        </member>
        <member name="E:SimpleFixture.Impl.TypedConventions.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="T:SimpleFixture.ReturnConfiguration`1">
            <summary>
            Class used to configure when a return value should be used
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.#ctor(SimpleFixture.Conventions.FilteredConvention{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="convention">filter convention</param>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.For``1">
            <summary>
            Use return value for specific parent types
            </summary>
            <typeparam name="TValue">filter type</typeparam>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenNamed(System.String)">
            <summary>
            Filter based on name (Parameter name or Property name)
            </summary>
            <param name="name">name to match exactly</param>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenNamed(System.Func{System.String,System.Boolean})">
            <summary>
            Filter based on name function (Parameter name or Property name)
            </summary>
            <param name="namedFunc">name func used to filter</param>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenMatching(System.Func{SimpleFixture.DataRequest,System.Boolean})">
            <summary>
            Filter based on data request
            </summary>
            <param name="matchingFunc">filter method</param>
            <returns>return configuration</returns>
        </member>
    </members>
</doc>
